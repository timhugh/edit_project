#!/usr/bin/env bash

set -euo pipefail

########################################
# Constants
########################################

RED_TEXT='\e[31m'
YELLOW_TEXT='\e[33m'
GREEN_TEXT='\e[32m'
DEFAULT_TEXT='\e[0m'

ERROR="${RED_TEXT}[ERROR]${DEFAULT_TEXT}"
WARNING="${YELLOW_TEXT}[WARNING]${DEFAULT_TEXT}"

EDIT_PROJECT_SCRIPT="${HOME}/.local/share/edit_project.sh"
EDIT_PROJECT_CONFIG="${HOME}/.config/edit_project.conf"

########################################
# Load configuration
########################################

root_dir=""
auto_clone=""
use_ssh=""
github_username=""
editor=""
source "${EDIT_PROJECT_CONFIG}" 2>/dev/null || true

user_input=$1

########################################
# Helper functions
########################################

# This script uses stdout to communicate back to a caller (specifically, the bash function in this repo).
# As a result, we use stderr to output messages to the user, and stdout only for the final output.
result() {
    echo $1 >&1
}
log() {
    echo -e $1 >&2
}

parse_repo_paths() {
    local -n _repo_url=$1
    local -n _repo_path=$2
    local input="$3"

    # If the input is a git SSH url, extract the path after the colon
    if [[ "$input" =~ ^git@[^:]+:(.+)$ ]]; then
        _repo_url="$input"
        _repo_path="${BASH_REMATCH[1]}"

    # If the input is a git HTTPS url, extract the path after the domain
    elif [[ "$input" =~ ^https?://[^/]+/(.+)$ ]]; then
        _repo_url="$input"
        _repo_path="${BASH_REMATCH[1]}"

    # If the input is a user/repo format, return it as is
    elif [[ "$input" =~ ^[^/]+/[^/]+$ ]]; then
        if [ "$use_ssh" = "true" ]; then
            _repo_url="git@github.com:$input.git"
        else
            _repo_url="https://github.com/$input.git"
        fi
        _repo_path="$input"

    # If the input is just a repo name, append it to the default user name
    elif [[ "$input" =~ ^[^/]+$ ]]; then
        if [ -z "$github_username" ]; then
            log "${ERROR} configuration is incomplete! github_username is not set. could not infer path for '$input'."
            exit 1
        fi
        if [ "$use_ssh" = "true" ]; then
            _repo_url="git@github.com:${github_username}/$input.git"
        else
            _repo_url="https://github.com/${github_username}/$input.git"
        fi
        _repo_path="${github_username}/$input"

    # Otherwise, we don't know how to handle this input
    else
        log "${ERROR} Could not parse '$input' to a repository path."
        exit 1
    fi
}

########################################
# Validate configuration and inputs
########################################

if (( BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 3 )) || (( BASH_VERSINFO[0] < 4 )); then
    log "${ERROR} sorry, this script requires Bash 4.3 or higher ðŸ¥²"
    log "your current bash version is ${BASH_VERSION}"
    log "please upgrade bash and try again if you want to use this script"
    exit 1
fi

if [ -z "$root_dir" ]; then
    log "${WARNING} configuration is incomplete! root_dir is not set, defaulting to ${HOME}/git and disabling auto-cloning."
    root_dir="${HOME}/git"
    auto_clone="false"
fi

if [ -z "$auto_clone" ]; then
    log "${WARNING} configuration is incomplete! auto_clone is not set, defaulting to false."
    auto_clone="false"
fi

if [ -z "$use_ssh" ]; then
    log "${WARNING} configuration is incomplete! use_ssh is not set, defaulting to use HTTPS."
    use_ssh="false"
fi

if [ -z "$github_username" ]; then
    log "${WARNING} configuration is incomplete! github_username is not set. short repo names will not work."
fi

if [ -z "$user_input" ]; then
  log "Usage: $0 <repository-name>"
  exit 1
fi

# Determine the repository URL and path from the input/config
declare repo_url repo_path
parse_repo_paths repo_url repo_path "$user_input"
full_path="${root_dir}/${repo_path}"

# Check if repository exists locally and handle auto-cloning if necessary
if [ ! -d "$full_path" ]; then
    if [ "$auto_clone" = "true" ]; then
        log "Cloning '$repo_url' to '$full_path'..."
        git clone "$repo_url" "$full_path" 1>&2
    else
        log "${ERROR} Repository path '$full_path' does not exist and auto-clone is disabled."
        exit 1
    fi
fi

# Output the final path
result "$full_path"
